# AlgorithmHomework

[C++] 20141212-大数据算法-实现DGIM算法

[C++] 20150507-算法复杂度分析-VertexCover

[C++] 20150613-算法复杂度分析-删数


[Latex] Reports

***



## DGIM

### About DGIM Homework

*实验目的*

熟悉DGIM算法的运行过程

*实验内容*

对于正整数流(数的范围为1到2𝑚 )，用DGIM算法估 计流中大小为N的窗口内最近 𝑘(1 ≤ 𝑘 ≤ 𝑁) 个整数的和。其中，𝑚 = 8，𝑁 = 100,000,000，𝑘 = 50000000。

*实验详细过程*

利用random函数依次产生随机的1到28的正整数。 当产生的数字超过100,000,000个时开始估计，每新产生1000,000个数后，估计一个值。 具有相同大小的桶的数目r可以取2,3,4....，不做限制。


### About DGIM

*详见 《6流算法》的课件*

DGIM算法简介

该算法能够使用 𝑂(𝑙𝑜𝑔2𝑁) 位来表示大小为N 位的窗口，同时能保证窗口内1数目的估计错 误率不高于50%。后面我们将介绍对该算法 的改进，改进之后的算法能够在仍然只使用 𝑂(𝑙𝑜𝑔2𝑁)位的情况下，将估计的错误率降到 任意大于0的分数𝜀之内(尽管当𝜀不断下降时 ，该复杂度会乘以某个不断增大的常数因子 )。

***



## VertexCover

D10292. vertex cover

时间限制：2.0s   内存限制：256.0MB   Special Judge

总提交次数：2274   AC次数：357   平均分：42.75

*问题描述*

给定一个N个点M条边的无向图G（点的编号从1至N），问是否存在一个不超过K个点的集合S，使得G中的每条边都至少有一个点在集合S中。

*输入格式*

输入的第一行包含一个整数T，表示数据的组数。

接下来T组数据中：每组输入的第一行包含三个整数n, m, k，分别表示图的点数，边数，集合点数的最大值。接下来m行，每行2个正整数x，y，表示编号为 x 的节点与编号为 y 的节点间有一条边相连。

*输出格式*

对于每组测试数据，若其存在解，则将解输出出来：第一行为一个整数t，表示所选点集的大小；第二行为t个整数，表示所选的点的编号。如果存在多组解，只要输出其中一种方案即可（会有special judge程序对你的输出进行检查）。

若该组测试数据不包含解，则输出一个数-1（一行）。

*数据规模和约定*

对于80%的数据，满足 0<n<=20, m<=200, k<=20。
所有的数据满足 0<n<=100, m<=5000, k<=20。

***



## DeleteNum

http://www.tsinsen.com/D10690

D10690. 删数

时间限制：3.0s   内存限制：512.0MB  

*问题描述*

　　现有一个n位数，你需要删除其中的k位，请问如何删除才能使得剩下的数最大？
　　比如当数为2319274 k=1时，删去2变成319274后是可能的最大值。

*输入格式*

　　输入的第一行包含一个整数T，表示数据的组数。
　　接下来T组数据中：每组输入的仅有一行包含1个n位数以及数k，内容如前所述。

*输出格式*

　　对于每组测试数据，输出将n删除k位数后的最大数，数据保证最大数>0。

*样例输入*

2
8800932422 1
4736167090 2

*样例输出*

880932422
76167090

*数据规模和约定*

　　对于80%的数据，满足 0<n<=2000, k<=min(1000,n-1)。
　　所有的数据满足 T=40 0<n<=100000, k<=min(1000,n-1)。



