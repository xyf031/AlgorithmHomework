# AlgorithmHomework

[C++] 20141212-大数据算法-实现DGIM算法
[C++] 20150507-算法复杂度分析-VertexCover
[C++] 20150613-算法复杂度分析-删数

[Latex] Reports



***
## DGIM

### About DGIM Homework

*实验目的*
熟悉DGIM算法的运行过程 实验内容
对于正整数流(数的范围为1到2𝑚 )，用DGIM算法估 计流中大小为N的窗口内最近 𝑘(1 ≤ 𝑘 ≤ 𝑁) 个整数的和。
其中，𝑚 = 8，𝑁 = 100,000,000，𝑘 = 50000000。

*实验详细过程*
利用random函数依次产生随机的1到28的正整数。 当产生的数字超过100,000,000个时开始估计，每新产
生1000,000个数后，估计一个值。 具有相同大小的桶的数目r可以取2,3,4....，不做限制。



### About DGIM
*详见 《6流算法》的课件*

DGIM算法简介
该算法能够使用 𝑂(𝑙𝑜𝑔2𝑁) 位来表示大小为N 位的窗口，同时能保证窗口内1数目的估计错 误率不高于50%。后面我们将介绍对该算法 的改进，改进之后的算法能够在仍然只使用 𝑂(𝑙𝑜𝑔2𝑁)位的情况下，将估计的错误率降到 任意大于0的分数𝜀之内(尽管当𝜀不断下降时 ，该复杂度会乘以某个不断增大的常数因子 )。

### My Report

大数据算法基础

一、算法思想

● 存储结构
首先需要计算一个重要参数，即在窗口大小为N、同大小桶个数不超过r的情况下，最大桶的大小上界是多少。该上界的对数取整记为bucketMaxNum。在最糟情况下，有：
 
解得：注：由于r比N小得太多，所以约等式成立。程序中使用精确上界来新建数组，但是本文档中的复杂度分析将使用约等的上界。
 
每种大小的桶在每次调整之后最多有r个，在每次调整之前可能会多一个，即r+1个，所以桶的存储使用数组结构，长度是bucketMaxNum * (r + 1)。桶的大小不需要存储，通过其在数组中的位置可以直接得知，所以桶的信息量只是时间戳。本程序中使用N=100000000，所以时间戳不会超过int范围，每个桶占用的内存是sizeof(int)=4 Byte。
 
每个大小的桶在内存中有r+1个存储位置，如果第r+1个出现，那么需要合并2个最早的桶来腾出空位。总之，调整后的桶的r+1个位置中至少有一个是空位用来接受新的桶。这个位置也需要存储，新桶插入的位置使用数组存储，长度是bucketMaxNum，由于每个数字都比较小（0~r），本程序中使用short（视自行设定的r大小而定）。
 
总之，本程序的存储结构如下：
1、桶的信息只存储时间戳，用int类型。
2、桶存放于数组bucketStoreS中，长度bucketMaxNum * (r + 1)，元素类型“桶”。
3、新桶插入位置存放于数组bucketIndexS中，长度bucketMaxNum，元素类型short。
 
● 程序组成

主体包括三个程序：接受流数据的DGIM程序、保持桶性质的keepDGIM程序、估计结果的estimateDGIM程序。

Main:
由于是1~2^m的正整数流，所以模拟时使用0~2^m-1的数据流，最后在估计结果上+N即可。

二、算法复杂度

● 空间复杂度
由于使用了m个DGIM同时处理，所以总的空间是单个DGIM的m倍：

注：此处大小表示占用多少个二进制位，其中sizeof(int)和sizeof(short)分别用和代替。

● 时间复杂度
每次保持一遍桶性质，需要。每收到一个1，新建桶的时间是常数O(1)，之后保持一遍桶性质。最糟情况下，复杂度是
估计结果时遍历一遍bucketStoreS数组，对于每个桶的处理是常数时间，总的复杂度是

由于m个DGIM同时运行，总的复杂度在最糟情况下是。

三、运行结果
略


***
## VertexCover

D10292. vertex cover
时间限制：2.0s   内存限制：256.0MB   Special Judge
总提交次数：2274   AC次数：357   平均分：42.75

问题描述
　　给定一个N个点M条边的无向图G（点的编号从1至N），问是否存在一个不超过K个点的集合S，使得G中的每条边都至少有一个点在集合S中。

输入格式
　　输入的第一行包含一个整数T，表示数据的组数。
　　接下来T组数据中：每组输入的第一行包含三个整数n, m, k，分别表示图的点数，边数，集合点数的最大值。接下来m行，每行2个正整数x，y，表示编号为 x 的节点与编号为 y 的节点间有一条边相连。


输出格式
　　对于每组测试数据，若其存在解，则将解输出出来：第一行为一个整数t，表示所选点集的大小；第二行为t个整数，表示所选的点的编号。如果存在多组解，只要输出其中一种方案即可（会有special judge程序对你的输出进行检查）。
　　若该组测试数据不包含解，则输出一个数-1（一行）。


数据规模和约定
　　对于80%的数据，满足 0<n<=20, m<=200, k<=20。
　　所有的数据满足 0<n<=100, m<=5000, k<=20。



***
## DeleteNum

http://www.tsinsen.com/D10690
D10690. 删数
时间限制：3.0s   内存限制：512.0MB  

问题描述
　　现有一个n位数，你需要删除其中的k位，请问如何删除才能使得剩下的数最大？
　　比如当数为2319274 k=1时，删去2变成319274后是可能的最大值。

输入格式
　　输入的第一行包含一个整数T，表示数据的组数。
　　接下来T组数据中：每组输入的仅有一行包含1个n位数以及数k，内容如前所述。

输出格式
　　对于每组测试数据，输出将n删除k位数后的最大数，数据保证最大数>0。

样例输入
2
8800932422 1
4736167090 2

样例输出
880932422
76167090

数据规模和约定
　　对于80%的数据，满足 0<n<=2000, k<=min(1000,n-1)。
　　所有的数据满足 T=40 0<n<=100000, k<=min(1000,n-1)。



